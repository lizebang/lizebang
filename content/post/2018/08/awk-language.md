---
title: 'AWK 语言'
slug: awk-language
date: 2018-08-27
draft: true
autoThumbnailImage: false
coverImage: /images/cover.jpeg
metaAlignment: center
categories:
  - skill
tags:
  - awk
  - script
  - shell
keywords:
  - awk
  - script
  - shell
---

最简单的 awk 程序是一个由多个 **模式–动作** 语句构成的序列。

<!--more-->

```awk
pattern { action }
pattern { action }
...
```

对每一个与当前行匹配的模式，对应的动作就会执行。一个缺失的模式匹配每一个输入行，因此每一个不带有模式的动作对每一个输入行都会执行。只含有模式而没有动作的语句，会打印每一个匹配模式的输入行。

输入文件 countries 每一行都包括一个国家的名字，面积（以千平方英里为单位），人口（以百万为单位），以及这个国家所在的大陆。

```data
USSR    8649 275  Asia
Canada  3852 25   North America
China   3705 1032 Asia
USA     3615 237  North America
Brazil  3286 134  South America
India   1267 746  Asia
Mexico  762  78   North America
France  211  55   Europe
Japan   144  120  Asia
Germany 96   61   Europe
England 94   56   Europe
```

**程序格式**

**模式–动作** 语句，以及动作内的语句通常用换行符分隔，但是若干条语句也可以出现在同一行，只要它们之间用分号分开即可。一个分号可以放在任何语句的末尾。

动作的左花括号必须与它的模式在同一行，而剩下的部分，包括右花括号，则可以出现在下面几行。

空行会被忽略，它们可以插入在语句之前或之后，用于提高程序的可读性。空格与制表符可以出现在运算符与操作数的周围，同样也是为了提高可读性。

注释可以出现在任意一行的末尾。一个注释以井号（#）开始，以换行符结束。

```awk
{ print $1, $3 } # print country name and population
```

一条长语句可以分散成多行，只要在断行处插入一个反斜杠即可。

```awk
{ print \
        $1,  # country name
        $2,  # area in thousands of square miles
        $3 } # population in millions
```

语句可以在逗号之后断行，并且注释可以出现在断行的末尾。

## 模式

模式控制着动作的执行：当模式匹配时，相应的动作便会执行。

1.`BEGIN{ statements}`

在输入被读取之前，statements 执行一次。

2.`END{ statements}`

当所有输入被读取完毕之后，statements 执行一次。

3.`expression{ statements}`

每碰到一个使 expression 为真的输入行，statements 就执行。expression 为真指的是其值非零或非空。

4.`/regular expression/ { statements}`

当碰到这样一个输入行时，statements 就执行，输入行含有一段字符串，而该字符串可以被 regular expression 匹配。

5.`compound pattern { statements}`

一个复合模式将表达式用 &&（AND）、||（OR）、!（NOT），以及括号组合起来，当 compound pattern 为真时，statements 执行。

6.`pattern1, pattern2 { statements}`

一个范围模式匹配多个输入行，这些输入行从匹配 pattern1 的行开始，到匹配 pattern2 的行结束（包括这两行），对这其中的每一行执行 statements。（pattern1 与 pattern2 可以匹配同一行）

BEGIN 与 END 不与其他模式组合。一个范围模式不能是其他模式的一部分。BEGIN 与 END 是唯一两个不能省略动作的模式。

### BEGIN 与 END

BEGIN 与 END 这两个模式不匹配任何输入行。实际情况是，当 awk 从输入读取数据之前 BEGIN 的语句开始执行，当所有输入数据被读取完毕 END 的语句开始执行。于是，BEGIN 与 END 分别提供了一种控制初始化与扫尾的方式。BEGIN 与 END 不能与其他模式作组合。如果有 多个 BEGIN 与其关联的动作会按照它们在程序中出现的顺序执行，这种行为对多个 END 同样适用。

BEGIN 的一个常见用途是更改输入行被分割为字段的默认方式。分割字符由一个内建变量 FS 控制。默认情况下字段由空格或（和）制表符分割，此时 FS 的值被设置为一个空格符。将 FS 设置成一个非空格字符，就会使该字符成为字段分割符。

下面这个程序在 BEGIN 的动作里将字段字割符设置为制表符（\t），END 打印总和：

```awk
# print countries with column headers and totals
BEGIN { FS = "\t" # make tab the field separator
        printf("%10s %6s %5s %s\n\n",
               "COUNTRY", "AREA", "POP", "CONTINENT")
      }
      { printf("%10s %6d %5d %s\n", $1, $2, $3, $4)
        area = area + $2
        pop = pop + $3
      }
END   { printf("\n%10s %6d %5d\n", "TOTAL", area, pop) }
```

### 将表达式用作模式

就像大多数程序设计语言一样，awk 拥有非常丰富的用来描述数值计算的表达式，但是与许多语言不同的是，awk 还有用于描述字符串操作的表达式。string 都表示一个由 0 个或多个字符组成的序列。这些字符串可以存储在变量中，也可以以字符串常量的形式出现。字符串 "" 不包括任何字符, 叫做 **空字符串**。术语 **子字符串** 表示一个字符串内部的，由 0 个或多个字符组成的连续序列。对任意一个字符串，空字符串都可以看作是该字符串第一个字符之前的，长度为 0 的子字符串，或者是一对相邻字符之间的子字符串，又或者是最后一个字符之后的子字符串。

任意一个表达式都可以用作任意一个运算符的操作数。如果一个表达式拥有一个数值形式的值，而运算符要求一个字符串值，那么该数值会自动转换成字符串。类似地，当运算符要求 一个数值时，字符串被自动转换成数值。

任意一个表达式都可以当作模式来使用。如果一个作为模式使用的表达式，对当前输入行的求值结果非零或不为空，那么该模式就匹配该行。典型的表达式模式是那些涉及到数值或字符串比较的表达式。关系运算符列在下表中：

| 运算符 |    意义    |
| :----: | :--------: |
|   <    |    小于    |
|   <=   | 小于或等于 |
|   ==   |    等于    |
|   !=   |   不等于   |
|   >=   | 大于或等于 |
|   >    |    大于    |
|   ~    |    匹配    |
|   !~   |   不匹配   |

如果模式是一个比较表达式，当当前行使该条件满足时，这个模式就算是匹配该输入行。如果模式是一个算术表达式，如果该表达式的值非零，那么当前输入行被匹配。如果模式是一个字符串表达式，当表达式的字符串值非空时，当前输入行被匹配。

在一个关系比较中，如果两个操作数都是数值，关系比较将会按照数值比较进行。否则的话，数值操作数会被转换成字符串，再将操作数按字符串的形式进行比较。两个字符串间的比较以字符为单位逐个相比，字符间的先后顺序依赖于机器的字符集，大多数情况下是 ASCII 字符集。

### 字符串匹配模式

awk 提供了一种称为 **正则表达式** 的表示法，它可以用来指定和匹配一个字符串。正则表达式在 Unix 环境用得非常普遍，包括文本编辑器与 shell。受限形式的正则表达式也出现在其他系统中，在 MS-DOS 中可以用 “通配符” 指定一个文件名集合。

一个 **字符串匹配模式** 测试一个字符串是否包含一段可以被正则表达式匹配的子字符串。

最简单的正则表达式是仅由数字与字母组成的字符串，为了将一个正则表达式切换成一个模式，只需要用一对斜杠包围起来即可。注意，正则表达式中空格是有意义的。

字符串匹配模式：

1.`/regexpr/`

当当前输入行包含一段能够被 regexpr 匹配的子字符串时，该模式被匹配。

2.`expression ~ /regexpr/`

如果 expression 的字符串值包含一段能够被 regexpr 匹配的子字符时，该模式被匹配。

3.`expression !~ /regexpr/`

如果 expression 的字符串值不包含能够被 regexpr 匹配的子字符串，该模式被匹配。

在 ~ 与 !~ 的语境中，任意一个表达式都可以用来替换 /regexpr/。

匹配所有第 4 个字段包含 Asia 的输入行：

```awk
$4 ~ /Asia/
```

匹配所有第 4 个字段 **不** 包含 Asia 的输入行：

```awk
$4 !~ /Asia/
```

### 正则表达式

正则表达式是一种用于指定和匹配字符串的表示法，一个正则表达式是一个基本表达式或者是多个子表达式通过运算符组合而成.。

正则表达式：

1.正则表达式的元字符包括：
`\ ^ $ . [ ] | ( ) * + ?`

2.一个基本的正则表达式包括下面几种：

- 一个不是元字符的字符，例如 `A`，这个正则表达式匹配的就是它本身。
- 一个匹配特殊符号的转义字符：`\t` 匹配一个制表符。
- 一个被引用的元字符，例如 `\*`，按字面意义匹配元字符。
- `^` 匹配一行的开始。
- `$` 匹配一行的结束。
- `.` 匹配任意一个字符。
- 一个字符类：`[ABC]` 匹配字符 A、B 或 C。
- 字符类可能包含缩写形式：`[A-Za-z]` 匹配单个字母。
- 一个互补的字符类：`[^0-9]` 匹配任意一个不是数字的字符。

  3.这些运算符将正则表达式组合起来：

  - 选择：`A|B` 匹配 A 或 B。
  - 拼接：`AB` 匹配后面紧跟着 B 的 A。
  - 闭包：`A*` 匹配 0 个或多个 A。
  - 正闭包：`A+` 匹配一个或多个 A。
  - 零或一：`A?` 匹配空字符串或 A。
  - 括号：被 `(r)` 匹配的字符串，与 r 所匹配的字符串相同。

字符 `\ ^ $ . [ ] | ( ) * + ?` 叫作 **元字符**，之所以这样称呼是因为它们具有特殊的意义。为了在正则表达式中保留元字符的字面意义，需要在字符的前面加上反斜杠。于是，`\$` 匹配普通字符 \$。如果某个字符前面冠有 \，我们就说该字符是被 **引用** 的。

由一组被包围在方括号中的字符组成的正则表达式称为 **字符类**，这个表达式匹配字符类中的任意一个字符。

使用连字符的字符类可以表示一段字符范围，紧跟在连字符左边的字符定义了范围的开始，紧跟在连字符右边的字符定义了范围的结束。`[0-9]` 匹配任意一个数字，`[a-zA-Z][0-9]` 匹配一个后面紧跟着一个数字的字母，`[A-Za-z-]+` 匹配一个可能包含连字符的单词。

一个 **互补** 的字符类在 [ 之后以 ^ 开始. 这样一个类匹配任意一个不在类中的字符，“类中的字符” 指的是方括号内排在脱字符之后的那些字符。`[^0-9]` 匹配任意一个不是数字的字符，`[^a-zA-Z]` 匹配任意一个不是字母的字符。

在一个字符类中，所有的字符都具有它自身的字面意义，除了引用字符 \、互补字符类开头的 ^ 以及两个字符间的 -。[.] 匹配一个句点，^[^^] 匹配不以脱字符 ^ 开始的字符串。

可以使用括号来指定正则表达式中的各个成分如何组合。

有两种二元正则表达式运算符：选择与拼接。

- 选择运算符 | 用来指定一个选择：如果 r1 与 r2 是正则表达式，那么 r1|r2 所匹配的字 符串，与 r1 或者与 r2 匹配。

- awk 不存在显式的拼接运算符。如果 r1 与 r2 是正则表达式，那么 (r1)(r1)（在 (r1) 与 (r2) 之间没有空格）所匹配的字符串具有形式 xy，其中 x 被 r1 匹配，y 被 r2 匹配。如果被括号包围的正则表达式不包含选择运算符，那么 r1 或 r2 两边的括号就可以省略。

符号 _、+ 与 ? 是一元运算符，用来指定正则表达式的重复次数。如果 r 是一个正则表达式，那么 (r)_ 所匹配的字符串含有零个或连续多个能被 r 匹配的子符串。r? 匹配的字符串，要么是空字符串，要么是能够被 r 匹配的字符串。如果 r 是一个基本的正则表达式，那么括号可以省略。

在正则表达式中，选择运算符 | 的优先级最低，然后是拼接运算，最后是重复运算符 \*、+ 与 ?。与算术表达式的规则一样，优先级高的运算符优先处理。

这里列出了一些比较有用的字符串匹配模式的例子：

- 匹配含有且只含有数字的输入行。

  ```awk
  /^[0-9]+$/
  ```

- 输入行有且仅有 3 个数字。

  ```awk
  /^[0-9][0-9][0-9]$/
  ```

- 十进制小数，符号与小数部分是可选的。

  ```awk
  /^(\+|-)?[0-9]+\.?[0-9]*$/
  ```

- 也是匹配十进制小数，带有可选的符号与小数部分。

  ```awk
  /^[+-]?[0-9]+[.]?[0-9]*$/
  ```

- 浮点数，符号与指数部分是可选的。

  ```awk
  /^[+-]?([0-9]+[.]?[0-9]*|[.][0-9]+)([eE][+-]?[0-9]+)?$/
  ```

- 一个字母，后面再跟着任意多个字母或数字（比如 awk 的变量名）。

  ```awk
  /^[A-Za-z][A-Za-z0-9]*$/
  ```

- 一个字母，又或者是一个后面跟着一个数字的字母（比如 Basic 的变量名）。

  ```awk
  /^[A-Za-z]$|^[A-Za-z][0-9]$/
  ```

- 同样是一个字母，又或者是一个后面跟着一个数字的字母。

  ```awk
  /^[A-Za-z][0-9]?$/
  ```

在正则表达式与字符串内部,awk 使用一个特定的字符序列 -- 转义序列，去表示那些无法用其他方式表示的字符。

| 序列   | 意义                                                             |
| :----- | :--------------------------------------------------------------- |
| `\b`   | 退格                                                             |
| `\f`   | 换页                                                             |
| `\n`   | 换行                                                             |
| `\r`   | 回车                                                             |
| `\t`   | 制表符                                                           |
| `\ddd` | 八进制数 ddd，ddd 含有 1 到 3 个数字, 每个数字的值在 0 到 7 之间 |
| `\c`   | c 表示元字符（举例来说，\\ 表示反斜杠，\" 表示双引号）           |

下表总结了正则表达式，以及它们所匹配的字符串。运算符按优先级递增的顺序列出。

|    表达式     | 匹配                                                                                          |
| :-----------: | :-------------------------------------------------------------------------------------------- |
|      `c`      | 非元字符 c                                                                                    |
|     `\c`      | 转义序列或字面意义上的 c                                                                      |
|      `^`      | 字符串的开始                                                                                  |
|      `$`      | 字符串的结束                                                                                  |
|      `.`      | 任意一个字符                                                                                  |
|  `[c1c2...]`  | 任意一个在 c1c2... 中的字符                                                                   |
| `[^c1c2...]`  | 任意一个不在 c1c2... 中的字符.                                                                |
| `[c1-c2...]`  | 任意一个在范围内的字符，范围由 c1 开始，由 c2 结束                                            |
| `[^c1-c2...]` | 任意一个不在范围内的字符，范围由 c1 开始，由 c2 结束                                          |
|    `r1|r2`    | 任意一个被 r1 或 r2 匹配的字符串                                                              |
|  `(r1)(r2)`   | 任意一个字串 xy，其中 r1 匹配 x，而 r2 匹配 y，如果当中不含有选择运算符，那么括号是可以省略的 |
|    `(r)*`     | 零个或连续多个能被 r 匹配的字符串                                                             |
|    `(r)+`     | 一个或连续多个能被 r 匹配的字符串                                                             |
|    `(r)?`     | 零个或一个能被 r 匹配的字符串                                                                 |
|     `(r)`     | 任意一个能被 r 匹配的字符串                                                                   |

### 复合模式

一个复合模式是一个组合了其他模式的表达式，通过括号，逻辑运算符 ||、&&、! 进行组合。如果表达式的值为真，那么复合模式就匹配当前输入行。

运算符 || 优先级最低，再往高是 &&，最高的是 !。&& 与 || 从左至右计算操作数的值，一旦已经知道整个表达式的值，计算便停止。

### 范围模式

一个范围模式由两个被逗号分开的模式组成，正如

```awk
pat1 , pat 2
```

一个范围模式匹配多个输入行，这些输入行从匹配 pat1 的行开始，到匹配 pat2 的行结束，包括这两行。pat2 可以与 pat1 匹配到同一行，这时候模式的范围大小就退化到了一行。

一旦范围的第一个模式匹配到了某个输入行，那么整个范围模式的匹配就开始了。如果范围模式的第二个模式一直都没有匹配到某个输入行，那么范围模式会一直匹配到输入结束。
